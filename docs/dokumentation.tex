\documentclass[12pt,titlepage]{article}

\usepackage{ngerman,amsmath,graphicx,a4wide,fontspec,hyperref}
\setmainfont{Helvetica Neue}
\setmonofont{Menlo Regular}

\begin{document}

\title{Miniprojekt: \\ Minimax-Maschine \\ Dokumentation}
\author{Clemens Pollak, Robin Thrift, Max Boll}
\date{Hardware Projekt 2014 \\ 14.11.2014}
\maketitle

\tableofcontents

\newpage

\section{Einleitung} 
Unser gew{\"a}hltes Thema befasst sich mit der Minimax-Maschine und mit der Realisierung von Algorithmen auf ihr. Dieses Thema soll im Rahmen des Hardware Praktikums bearbeitet werden und ist uns aus der Veranstaltung "'Grundlagen der Rechnerarchitektur"' bereits grundlegend bekannt.\\ Um unsere Vorbereitung auf dieses Projekt dokumentieren und strukturieren zu k{\"o}nnen, erstellen wir ein Pflichtenheft. Dieses Pflichtenheft wird nur unsere Vorbereitung beinhalten und es wird au{\ss}erdem eine weitere Dokumentation der Ergebnissen geben. Außerdem wird es w{\"a}hrend der Bearbeitung unseres Projects einen Leitfaden für uns darstellen, der die Implementierung der L{\"o}sung vereinfacht und beschleunigt.


\section{Aufgabenstellung}
Nach unserem Verst{\"a}ndniss ist das Ziel dieser Aufgabenstellung ein Algorithmus, welcher auf der Minimax-Maschine zu implementieren ist und eine sogenannte Paketanalyse betreibt. Dieser "'Paketanalyse"'-Algorithmus befasst sich mit dem Datenpaketen, welche im Speicher der Minimax-Maschine abgelegt sind.\\ Ein Datenpaket beginnt immer mit der Folge "'1110"' und besteht aus einem
Kopf mit einer L{\"a}nge von 80 Bits und einem Datenteil mit variabler L{\"a}nge. Der Kopf enth{\"a}lt die Kanalnummer zwischen der 32. und 47. Bitstelle. Zu einem Kanal k{\"o}nnen ein oder mehrere Pakete geh{\"o}ren, welche die selbe Kanalnummer haben.
Die Anzahl Bits, welche in den Speicher geladen werden, welche überprüft werden müssen wird als bekannt vorausgesetzt und wird in ein entsprechendes Register vorgeladen.\\
Nun soll der Algorithmus eine Datentabelle anlegen, welche sich au{\ss}erhalb der Speicherfelder der einzelnen Pakete befindet. Diese Datentabelle soll den Kanalnummern die L{\"a}ngen der jeweiligen Datenteile aller Pakete zuordenen um dann später exportiert zu werden. Diese Aufgabenstellung soll mit dem Minimax-Simulator simuliert und getestet werden. Die Maschine kann durch vorgegebene Bauteile erweitert werden, was sich aber auf die Bewertung auswirkt. Der Algorithmus wird in Form der sogenannten Steuertabelle implementiert und soll außerdem als Flussdiagramm abgegeben werden.

\newpage

\section{Ist-Analyse der Basis-Maschine}

Die Minimax-Maschine ist ein minimales Rechensystem welches aus einfachen Registern (Basis: \texttt{ACCU}, \texttt{PC}, \texttt{IR}, \texttt{MDR}, \texttt{MAR};
weitere k{\"o}nnen hinzuge{\"u}fgt werden), einer arithmetisch-logischen Einheit (ALU) und einem Hauptspeicher (HS) aufgebaut
ist und durch ein Mikropgramm gesteuert wird. Jedes dieser Register hat als Eingang mindestens die ALU und hat zusätzlich einen Eingang, der den Schreibzugriff regelt.\\
\begin{enumerate}
\item \texttt{ACCU}: Abk{\"u}rzung f{\"u}r "'Accumulator"' ein Zwischenspeicher, um mit \texttt{MDR} Operationen durchführen zu k{\"o}nnen.
\item \texttt{PC}: Abk{\"u}rzung f{\"u}r "'program counter"', enthält den Programmzähler, welcher den nächsten Befehl beeinflusst
\item \texttt{IR}: Abk{\"u}rzung f{\"u}r "'instruction register"', enthält Opcode(8 Bit) und Adressteil(24 bit).
\item \texttt{MDR}: Abk{\"u}rzung f{\"u}r "'memory data register"', enthält je nach Einstellung des Multiplexers texttt{MDR.Sel}, verschiede Daten entweder aus Hauptspecher oder aus der \texttt{ALU}.
\item \texttt{MAR}: Abk{\"u}rzung f{\"u}r "'memory adress register"', enth{\"a}lt die Speicheradresse an der aus dem Hauptspeicher Daten geladen oder geschrieben werde sollen.
\item \texttt{HS}: Abk{\"u}rzung f{\"u}r "'Hauptspeicher"', er wird mit 24-Bit durch \texttt{MAR} adressiert und gibt eine 32-Bit Zahl zur{\"u}ck. Auf die selbe Art funktioniert schreiben einer 32-Bit Zahl nat{\"u}rlich auch.
\end{enumerate}

\leavevmode \\

\begin{enumerate}
\item \texttt{ADD}: Addiert ALU-Eingang A und ALU-Eingang B
\item \texttt{SUB.B}: Subtrahiert ALU-Eingang A von ALU-Eingang B
\item \texttt{TRANS.A}: Schaltet den ALU-Eingang A durch
\item \texttt{TRANS.B}: Schaltet den ALU-Eingang B durch
\end{enumerate}

\leavevmode \\

Dabei sind die m{\"o}glichen Operationen auf die in der ALU implementieren
Operationen beschr{\"a}nkt (Basis: \texttt{ADD}, \texttt{SUB.B}, \texttt{TRANS.A}, \texttt{TRANS.B}). Die ALU kannn mit weiteren Operationen,
wie z. B. dem bitweisen UND, erg{\"a}nzt werden.\\
Um eine Operation auszuf{\"u}hren m{\"u}ssen {\"u}ber die Multiplexer \texttt{ALUSel.A} und \texttt{AluSel.B} zwei Operanden ausgew{\"a}hlt werden
und der ALU muss {\"u}ber die \texttt{ALU Ctrl}-Leitung der Code f{\"u}r die Operation {\"u}bergben werden. An den Multiplexern liegen sowohl
Konstanten als auch die Register an, welche zur ALU durchgeschaltet werden k{\"o}nnen. Das Ergebnis der Operation kann
entweder in einem Register oder (über MDR) im HS (Adresse im Register \texttt{MAR}) gespeichert werden. Zus{\"a}tzlich k{\"o}nnen s.g. Flags (Basis nur ein Flag \texttt{ALU RESULT == 0})
gesetzt werden, welche zur{\"u}ck zur Control Unit (CU) geleitet werden um z. B. bedingte Spr{\"u}nge auszuf{\"u}hren.

Abbildung 1 zeigt die uns vorliegende Basismaschine.

\leavevmode \\

Die uns vorliegende Minimax-Maschine arbeitet mit 32-Bit und speichert Werte mit 32-Bit in den Registern und im HS (\dq Little Endian\dq ).
Alle ALU-Operationen werden folglich alle mit 32-Bit ausgef{\"u}hrt. Dies stellt sich jedoch f{\"u}r unser Aufgabe als
Hindernis, da wir die Daten bitweise untersuchen m{\"u}ssen, Daten aus dem HS und den Registern jedoch nur als
32-Bit Zahlen auslesen k{\"o}nnen und nicht als einzelne Bits.

Folglich wird die Basismaschine um einige Konstanten, Operationen und Register erweitert werden müssen, welche im "'Implementierungskonzept'" n{\"a}her
aufgeführt sind. Abbildung 6 zeigt den Aufbau der erweiterten Maschine.

\newpage

\section{Finale Implementierung}
Wir haben das Hauptproblem in einige Teilprobleme aufgeteilt:
\begin{enumerate}
\item Das sequenzielle Auslesen des Hauptspeichers
\item Die Analyse der Daten
    \begin{enumerate}
    \item Das Erkennen der Startsequenz eines neuen Pakets
    \item Das Auslesen der Kanalnummer
    \end{enumerate}
\item Das Speichern der geforderten Daten im HS
\end{enumerate}

\subsection{Sequenzielles Auslesen aus dem Hauptspeicher}
Zun{\"a}chst m{\"u}ssen die abgelegten Daten sequenziell ausgelesen werden. Da die Anzahl der in den Speicher geladenen Bits
bekannt ist (im Register \texttt{LNGTH} abgelegt), kann hierzu ein Mikroprogramm implementiert werden, welches mithilfe
einer Schleife alle Speicherzellen ausliest, bis die Anzahl der ausgelesenen Bits gleich der Zahl im Register \texttt{LGNTH} ist.
Hierzu muss die Minimax-Maschine um ein Register erweitert werden, welches die aktuelle Speicheradresse enth{\"a}lt (anfangs 0),
und mit wir \texttt{ADDR} bezeichnen werden. Bei jeder Iteration wird der Wert an der Adresse \texttt{ADDR} im Register 
\texttt{MDR} gespeichert und steht somit dem Analyseprogramm zur Verf{\"u}gung. Nach der Analyse wird das Register \texttt{ADDR}
inkrementiert und es wird zur{\"u}ck zum Schleifenkopf gesprungen (Siehe Abb. 1 im Anhang).

\subsection{Analyse der Daten}
Die Analyse der Daten kann als einfacher endlicher Automat mit 2 Zuständen betrachtet werden (0, 1). Im ersten Zustand (0)
wurde noch kein Paket gefunden und es wird mit Hilfe einer Bitmaske ($1111_{2} = 15_{10}$) nach der Anfangssequenz gesucht. 
Wenn die Startsequenz gefunden wurde wird der Zustand verändert (zu 1) und es wird auf die nächste Zahl aus dem HS gewartet. 
In der nächsten Zahl aus dem HS befindet sich die Kanalnummer. Diese wird mit einer weiteren Bitmaske ausgelesen
und im Register \texttt{CHNL} abgelegt.
Wurde sowohl ein Paketanfang als auch eine Kanalnummer gefunden, so wird nun die Länge des Datenfeldes gezählt und im Register \texttt{DATAC} gespeichert, bis erneut die Startsequenz gefunden wird.
Wurde eine neue Startsequenz gefunden so wird von der Länge des Daten 16 abgezogen (16 Bits Overhead des Headers) und
es wird an das Speicherprogramm angegeben und es wird wieder in den zweiten Zustand (1) gewechselt.

\subsection{Ablegen der Daten im Hauptspeicher}
Ziel der Analyse ist es die Länge aller Datenpakete für jeden Kanal zu z{\"a}hlen und in eine Tabelle im Hauptspeicher abzulegen.
Dazu wird zunächst eine Anfangsadresse (Offset) gewählt (Register \texttt{OFFSET}), welche unsere Tabelle weit von den Eingabedaten
im Hauptspeicher platziert. Die Tabelle wird als einfaches indiziertes Array modelliert, in welchem die Kanalnummern die
Schlüssel sind. Nach dem Auslesen der Kanalnummer (abgelegt im Register \texttt{CHNL}) wird also die Speicherzelle mit der Adresse 
$\texttt{ACCU} + \texttt{OFFSET}$ mit Datenlänge (Register \texttt{DATAC}) addiert und an der gleichen Stelle wieder abgelegt (Siehe
Abb. 3 im Anhang)

\section{Angestrebte Projektergebnisse}
\begin{enumerate}
\item Die Tabelle, in der die einzelnen Kanalnummern und Paketl{\"a}ngen enthalten sind. (Als exportierte Speicherdatei)
\item Eine Dokumentation, welche unserer Implementierung im Detail beschreibt und m{\"o}glicherweise schwierige Stellen verst{\"a}ndlich erl{\"a}utert.
\item Einen exportierten Schaltplan der erweiterten Minimax-Maschine.
\end{enumerate}

\section{Projektdurchf{\"u}hrung}

\subsection{Zeitlicher Ablauf der Projektarbeit}

\begin{itemize}
\item [] \textbf{20.10.14} Besprechung des unseres Hardware Projekts
\item [] \textbf{31.10.14} Abgabe Pflichtenheft mit grober Skizze der L{\"o}sung
\item [] \textbf{05.11.14} Besprechung des Pflichtenhefts und Anfang der Implementierung des Problems
\item [] \textbf{14.11.14} Geplante Abgabe der Dokumentation des Projekts
\item [] \textbf{20.11.14} Geplante Pr{\"a}sentation unserer Lösung
\end{itemize}

\subsection{Erweiterungen der Minimax-Basis-Maschine}

\subsubsection{Register}

\begin{enumerate}
\item \texttt{COUNT}: Gesammtl{\"a}nge der Auszuwertenden Daten
\item \texttt{OFFSET}: F{\"u}r den Offsetwert, der bei der Speicherung der Längen addiert wird
\item \texttt{ADDR}: Ein Register f{\"u}r die aktuelle Adresse
\item \texttt{OLD}: Zwischenspeicher
\item \texttt{CHNL}: Hält die aktuelle Kanalnummer
\item \texttt{DATAC}: Zähler für Länge des Datenfeldes
\item \texttt{STATE}: Variable zum speichern des Status vom Analyseautomaten
\end{enumerate}

\subsubsection{ALU-Operationen}

\begin{enumerate}
\item \texttt{A AND B}: Bitweise Und-Verknüpfung
\end{enumerate}

\subsubsection{Konstanten}
\begin{enumerate}
\item \texttt{511 (1FF)}: OFFSET für die Speichertabelle
\item \texttt{15}: Bitmaske zur Erkennung der Startsequenz
\item \texttt{14}: Subtraktionswert zur Erkennung der Startsequenz
\item \texttt{31}: Bitmaske zum Auslesen der Kanalnummern (nur für Benchmark)
\item \texttt{32}: Speicherblockgröße
\item \texttt{-16}: Headeroverflow
\end{enumerate}

\leavevmode \\

\subsubsection{Multiplexer-Eingänge}

\begin{table}[h!]
    \begin{tabular}{l|l}
    Adresse & Wert              \\
    \hline  					\\
    0000     & 0                 \\
    0001     & 1                 \\
    0010     & ACCU (Register)   \\
    0011     & 15                \\
    0100     & 31                \\
    0101     & STATE (Register)  \\
    0110     & 32                \\
    0111     & 14                \\
    1000     & -16               \\
    1001     & OFFSET (Register) \\
    1010     & DATAC (Register)  \\
    \end{tabular}
    \caption{ALUSel.A}
\end{table}

\begin{table}[h!]
    \begin{tabular}{l|l}
    Adresse & Wert            \\
    \hline                    \\
    0000     & MDR (Register)  \\
    0001     & AT (Register)   \\
    0010     & PC (Register)   \\
    0011     & ACCU (Register) \\
    0100     & ADDR (Register) \\
    0101     & COUNT (Register) \\
    0110     & DATAC (Register) \\
    0111     & CHNL (Register) \\
    1000     & OLD (Register)  \\
    1001     & 511             \\
    \end{tabular}
    \caption{ALUSel.B}
\end{table}

\newpage

\subsection{Programmdruchlauf}
Als Beispiel werden hier die ersten 44 Bytes des zweiten Benchmarks untersucht (Für die vollständige Steuertabelle siehe Abbildung 7).

\leavevmode \\

\begin{table}[h!]
    \begin{tabular}{l|l}
    Adresse & Wert            \\
    \hline                    \\
    0     & 16843022  \\
    1     & 16842760  \\
    2     & 16843009  \\
    3     & 16843009  \\
    4     & 16843009  \\
    5     & 16843022  \\
    6     & 16842767  \\
    7     & 16843009  \\
    8     & 16843009  \\
    9     & 16843009  \\
    A     & 16843022  \\
    \end{tabular}
    \caption{Ersten 3200 Bit des zweiten Benchmarks interpretiert als 32-Bit-Zahlen}
\end{table}

\includegraphics[width=16cm]{listing/row1-4.png}
\leavevmode \\

Zunächst wird die Adresse gesetzt (anfangs 0) und der Wert an der Adresse ausgelesen und in \texttt{MDR} abgelegt.
Dies ist der Schleifenkopf, und \texttt{ADDR} entspricht der Lauf-Variable.
Wir ziehen 32 vom \texttt{COUNT}-Register ab, welches bereits mit der Anzahl Bits des Benchmarks gefüllt wurde.
Ist \texttt{COUNT} Null, ist das Programm vorbei, wenn nicht springen wir zum Analyseprogramm.
Im ersten Durchlauf liegt nun im Register \texttt{MDR} die Zahl 16843022.

\leavevmode \\
\includegraphics[width=16cm]{listing/row6.png}
\leavevmode \\

Entsprechend des Zustands wird hier unterschieden zwischen Kanalnummer- und Startsequenzsuche. Im ersten Durchlauf
wird natürlich erstmal eine Startsequenz gesucht, und der Zustand ist Null (0).

\leavevmode \\
\includegraphics[width=16cm]{listing/row7-8.png}
\leavevmode \\

Nun wird die Bitmaske auf den Wert aus \texttt{MDR} angewendet und anschließend die Startsequenz abgezogen, um
zu überprüfen, ob diese im Wert enthalten ist. Ist dies der Fall, so springen wir zur Zeile mit dem Label \dq new\dq
da es sich um ein neues Datenpaket handelt. In diesem konkreten Fall wenden wir also $16843022 \text{ AND } 15$ an, und finden
die Startsequenz.

\leavevmode \\
\includegraphics[width=16cm]{listing/row9-10.png}
\leavevmode \\

Hier wird die Datenlänge überprüft, welches wir jedoch für den Moment ignorieren können, wir überspringen im ersten Fall auch den Speicheralgorithmus, 
und machen mit Zeile 18 weiter:

\leavevmode \\
\includegraphics[width=16cm]{listing/row18-19.png}
\leavevmode \\

Da wir die Startsequenz gefunden haben setzen wir nun den Zustand auf 1 und initialisieren die Datenlänge mit 0. Danach springt
das Programm zurück zur Schleife:

\leavevmode \\
\includegraphics[width=16cm]{listing/row1-5.png}
\leavevmode \\

In Zeile 5 wird die Adresse im Register \texttt{ADDR} inkrementiert und wir springen zum Schleifenkopf zurück um die nächste
Iteration zu starten. Wir laden nun den Wert 16842760 aus dem Speicher und übergeben ihn dem Analyseprogramm.

\leavevmode \\
\includegraphics[width=16cm]{listing/row6.png}
\leavevmode \\

Wir überprüfen erneut den Zustand und springen nun zum Auslesen der Kanalnummer, da wir uns in Zustand 1 befinden.

\leavevmode \\
\includegraphics[width=16cm]{listing/row21-22.png}
\leavevmode \\

Mit der Bitmaske 31 lesen wir die Kanalnummer aus der Zahl aus, speichern sie im Register \texttt{CHNL}
und setzen anschließend den Zustand wieder auf 0 und springen zur Schleife
zurück.

\leavevmode \\
\includegraphics[width=16cm]{listing/row1-5.png}
\leavevmode \\

Nun laden wir den Wert 16843009 aus dem Speicher und übergeben ihn dem Analyseprogramm.

\leavevmode \\
\includegraphics[width=16cm]{listing/row6.png}
\leavevmode \\

Nun sind wir wieder im Zustand 0, suchen also wieder nach der Startsequenz.

\leavevmode \\
\includegraphics[width=16cm]{listing/row7-8.png}
\leavevmode \\

Die Startsequenz kann nicht gefunden werden, also springen wir zur Zeile 20.

\leavevmode \\
\includegraphics[width=16cm]{listing/row20.png}
\leavevmode \\

Wir addieren die Länge der ausgelassenen Zahl in Bits (32) zur aktuellen Gesamtlänge des Datenfeldes (hier 0) und
springen zurück zur Schleife.

\leavevmode \\
\includegraphics[width=16cm]{listing/row1-5.png}
\leavevmode \\

Wir überspringen für dieses Beispiel Block 4 im Speicher und machen mit Adresse 5 weiter; Wert: 16843022.

\leavevmode \\
\includegraphics[width=16cm]{listing/row7-8.png}
\leavevmode \\

Wir suchen erneut nach der Startsequenz und finden sie, nun ziehen wir 16 von der gezählten Länge ab (Anzahl Bits des Headers, die wir
mitgezählt haben) und übergeben dem Speicherprogramm:

\leavevmode \\
\includegraphics[width=16cm]{listing/row11-17.png}
\leavevmode \\

Zunächst wird die aktuelle Adresse zwischen gespeichert, danach addieren wir zu unserem OFFSET die Kanalnummer, und benutzen das Ergebnis
als neue Adresse. Dann wird der Aktuelle Wert an der Adresse ausgelesen und wir addieren unsere gerade gezählte Länge dazu (Zeile 15).
Anschließend wird der neue Wert im HS abgelegt und wird stellen die ursprüngliche Adresse wieder her.

\leavevmode \\
\includegraphics[width=16cm]{listing/row18-19.png}
\leavevmode \\

Nun wird wie zuvor die Datenlänge wieder mit 0 initialisiert, der Zustand auf 1 gesetzt und es wird zurück zur Schleife gesprungen.

\leavevmode \\

Dieser Vorgang wird nun wiederholt, bis das Register \texttt{COUNT} Null ist. Dabei ensteht für dieses Beispiel volgende Tabelle im HS:

\begin{table}[h!]
    \begin{tabular}{l|l}
    Adresse & Wert            \\
    \hline                    \\
    207   & 80       \\
    208   & 0        \\
    ...   & 0        \\
    20E   & 80       \\
    \end{tabular}
\end{table}

\newpage

\section{Anhang}

\subsection{Abb. 1: Basismaschine}
\includegraphics[width=13cm]{schematics.png}

\subsection{Abb. 2: Flussdiagramm des Speicherausleseprogramms}
\includegraphics[width=13cm]{readFromMemory.png}

\subsection{Abb. 3: Flussdiagramm des Analyseprogramms}
\includegraphics[width=13cm]{analyseData.png}

\subsection{Abb. 4: Flussdiagramm des Speicherprogramms}
\includegraphics[width=13cm]{saveToHS.png}

\subsection{Abb. 5: Flussdiagramm des Programms zum Überspringen des Datenfeldes}
\includegraphics[width=10cm]{skipBits.png}

\subsection{Abb. 6: Aufbau der erweiterten Maschine}
\includegraphics[width=10cm]{schematics_added.png}

\subsection{Abb. 7: Vollständige Steuertabelle}
\includegraphics[width=10cm]{signal_table.png}

\newpage

\section{Arbeitsaufteilung}
Da sich das vorliegende Problem sehr gut in kleinere Teilprobleme aufteilen lässt ergibt sich folgende 
Arbeitsteilung:
\leavevmode \\
\\
\begin{tabular}{|l|c|}
\hline
Robin Thrift &  Analyse-Algorithmus der ausgelesenen Daten \\
\hline
Clemens Pollak & sequentieller Einlesealgorithmus \\
\hline
Max Boll & Speicheralgorithmus \\
\hline
\end{tabular}
\leavevmode \\
\\
Dies beinhaltet auch die Dokumentation der jeweiligen Aufgabe (Da Git und LaTeX verwendet werden kann jedes 
Teammitglied gefahrlos zur Dokumentation beitragen).


\section{Hilfsmittel}
Wir haben folgende Quellen benutzt:
\begin{enumerate} 
\item Wikipedia: \dq Mask (computing)\dq \\ \string[\url{http://en.wikipedia.org/wiki/Mask_(computing)}\string]
\item Wikipedia: \dq Bitweiser Operator\dq \\ \string[\url{http://de.wikipedia.org/wiki/Bitweiser_Operator}\string]
\item Git VCS zur Quellcodeorganisation und Synchronisation
\item GitHub zur Projektorganisation und Quellcodesynchronisation
\item Flowcharts: \string[\url{https://www.draw.io}]
\item SRA Minimax-Simulator
\item Informationsfolien (Aufgabenstellung)
\item Materialen der Veranstaltung \dq Grundlagen der Rechnerarchitektur\dq von Prof. Dr.-Ing. habil. Jürgen Brehm
\end{enumerate}

\end{document}
